// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || arm || arm64 || loong64 || mips64le || mipsle || ppc64le || riscv64 || wasm

package ebpf

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

// loadTcFilter returns the embedded CollectionSpec for tcFilter.
func loadTcFilter() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_TcFilterBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load tcFilter: %w", err)
	}

	return spec, err
}

// loadTcFilterObjects loads tcFilter and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*tcFilterObjects
//	*tcFilterPrograms
//	*tcFilterMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadTcFilterObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadTcFilter()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// tcFilterSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tcFilterSpecs struct {
	tcFilterProgramSpecs
	tcFilterMapSpecs
	tcFilterVariableSpecs
}

// tcFilterProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tcFilterProgramSpecs struct {
	TcTorFilter *ebpf.ProgramSpec `ebpf:"tc_tor_filter"`
}

// tcFilterMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tcFilterMapSpecs struct {
	BlockedIps *ebpf.MapSpec `ebpf:"blocked_ips"`
}

// tcFilterVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tcFilterVariableSpecs struct {
	UnusedBlockedKey   *ebpf.VariableSpec `ebpf:"unused_blocked_key"`
	UnusedBlockedValue *ebpf.VariableSpec `ebpf:"unused_blocked_value"`
}

// tcFilterObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadTcFilterObjects or ebpf.CollectionSpec.LoadAndAssign.
type tcFilterObjects struct {
	tcFilterPrograms
	tcFilterMaps
	tcFilterVariables
}

func (o *tcFilterObjects) Close() error {
	return _TcFilterClose(
		&o.tcFilterPrograms,
		&o.tcFilterMaps,
	)
}

// tcFilterMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadTcFilterObjects or ebpf.CollectionSpec.LoadAndAssign.
type tcFilterMaps struct {
	BlockedIps *ebpf.Map `ebpf:"blocked_ips"`
}

func (m *tcFilterMaps) Close() error {
	return _TcFilterClose(
		m.BlockedIps,
	)
}

// tcFilterVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadTcFilterObjects or ebpf.CollectionSpec.LoadAndAssign.
type tcFilterVariables struct {
	UnusedBlockedKey   *ebpf.Variable `ebpf:"unused_blocked_key"`
	UnusedBlockedValue *ebpf.Variable `ebpf:"unused_blocked_value"`
}

// tcFilterPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadTcFilterObjects or ebpf.CollectionSpec.LoadAndAssign.
type tcFilterPrograms struct {
	TcTorFilter *ebpf.Program `ebpf:"tc_tor_filter"`
}

func (p *tcFilterPrograms) Close() error {
	return _TcFilterClose(
		p.TcTorFilter,
	)
}

func _TcFilterClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Exported wrapper for other packages.
type TcFilterObjects = tcFilterObjects

func LoadTcFilterObjects(obj *TcFilterObjects, opts *ebpf.CollectionOptions) error {
    return loadTcFilterObjects(obj, opts)
}


// Do not access this directly.
//
//go:embed tcfilter_bpfel.o
var _TcFilterBytes []byte
